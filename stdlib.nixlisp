(define nil __prim_null)
(define nil? (lambda (i) (__prim_equals i nil)))

(define car (lambda (i) (__prim_car i)))
(define cdr (lambda (i) (__prim_cdr i)))

(define cons (lambda (ca cd) (__prim_cons ca cd)))

(define true __prim_true)
(define false __prim_false)

(define add (lambda xs (fold-left __prim_plus 0 xs)))
(define mul (lambda xs (fold-left __prim_product 1 xs)))
(define eq? (lambda (x y) (__prim_equals x y)))

(define and (lambda xs (fold-left __prim_and true xs)))
(define or (lambda xs (fold-left __prim_or false xs)))
(define not (lambda (x) (if x false true)))

(define symbol-name (lambda (x) (__prim_symbol_name x)))

(define apply (lambda (f xs) (eval (cons f xs))))

(define cons? (lambda (x) (eq? (__prim_expr_type x) "cons")))
(define int? (lambda (x) (eq? (__prim_expr_type x) "int")))
(define attrset? (lambda (x) (eq? (__prim_expr_type x) "attrset")))

(define attr
  (lambda (attrset . path)
    (begin
      (define go
        (lambda (acc xs)
          (if (nil? xs)
            acc
            (go (__prim_get_attr (car xs) acc) (cdr xs))
          )
        )
      )
      (go attrset path)
    )
  )
)

(define fold-left (lambda (f init seq)
   (if (nil? seq)
       init
       (fold-left f
                  (f init (car seq))
                  (cdr seq)))))

(define-macro cond (lambda args
  (begin
    (define go (lambda (xs)
      (if
        (nil? xs)
        nil
        (begin
          (define clause (car xs))
          (define condition (car clause))
          (define value (car (cdr clause)))
          (cons 'if (cons condition (cons value (cons (go (cdr xs)) nil))))))))
    (go args))))
